//假设有  n  瓶饮料，每瓶饮料喝完会剩一个瓶盖。
//每三个瓶盖可以兑换一瓶饮料（不消耗额外的瓶盖）。
//问最多能喝到多少瓶饮料。
// Created by 仇皓然 on 24-12-1.
/*1.初始时有  n  瓶饮料，喝掉后得到  n  个瓶盖。
2.	将这些瓶盖以  3:1  的比例兑换新的饮料，并继续喝。
3.	每次兑换饮料时，剩下的瓶盖会继续参与后续兑换，直到瓶盖数少于 3。*/

#include<iostream>
using namespace std;

int main(){
    int n;
    cin>>n;//输入初始饮料数
    int total=n;//记录总共喝掉的饮料数

    while(n>=3){
      int new_drink = n / 3;//兑换的新的饮料数
      total += new_drink; //累计喝掉的饮料数
      n =new_drink + (n%3);//更新的总瓶盖数
    }
    cout<<total<<endl;
    }
//哎呦这么简单的题目我考试都没做出来，我当时不知道怎么搞瓶盖更新，
//就是不知道如何让新兑换的瓶盖加上剩下的瓶盖卡住了
//summary
/*1.明确两个状态：
• 当前有的瓶盖数。
• 通过这些瓶盖能兑换的新饮料数。
只要分清楚这两个状态，问题的逻辑就不会乱。
2. 写成步骤：
•用当前瓶盖数去兑换饮料，得到新饮料数；
• 剩下的瓶盖记住别丢掉，这些需要加回去一起更新瓶盖总数。
举个类似的例子：你去超市用代金券买东西，买完还剩一些券，
下次买时还能用上剩下的券和新赠的券一样的道理。

//核心思路
•	每次循环：
•	计算能换多少新饮料： new_drinks = n / 3
•	计算剩下的瓶盖： remain_caps = n % 3
•	更新总瓶盖： n = new_drinks + remain_caps
•	循环到瓶盖数小于 3 时停止。

//	n / 3 不仅代表新兑换的饮料数，还正好就是这些新饮料喝完后产生的瓶盖数。
所以，更新瓶盖时，我们只需要把新产生的瓶盖数  n / 3  和剩余的瓶盖数  n \% 3  加起来，
就得到了下一轮可用的瓶盖数。*/
